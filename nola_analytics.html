<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NOLA Analytics - Dashboard</title>
    <!-- 1. Carrega o Tailwind CSS para um design limpo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. Carrega o Chart.js para os gráficos -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- 3. Carrega a biblioteca de datas (para facilitar a manipulação) -->
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/weekday.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/isoWeek.js"></script>
    <script>
        dayjs.extend(dayjs_plugin_weekday);
        dayjs.extend(dayjs_plugin_isoWeek);
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                },
            },
        }
    </script>
</head>
<body class="bg-gray-100 font-sans">

    <!-- Cabeçalho -->
    <header class="bg-white shadow-sm">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 flex justify-between items-center">
            <h1 class="text-2xl font-bold text-gray-900">
                <span class="text-indigo-600">NOLA</span> Analytics
            </h1>
            <div class="flex items-center space-x-4">
                <span class="text-sm text-gray-700 hidden sm:block">Olá, <span class="font-medium">Maria</span></span>
                <!-- Seletor de Data (Controlador Principal) -->
                <div>
                    <label for="date-range" class="sr-only">Período</label>
                    <select id="date-range" name="date-range" class="rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-sm">
                        <option value="7">Últimos 7 dias</option>
                        <option value="30" selected>Últimos 30 dias</option>
                        <option value="90">Últimos 90 dias</option>
                        <option value="180">Últimos 6 meses</option>
                    </select>
                </div>
            </div>
        </div>
    </header>

    <!-- Área Principal do Dashboard -->
    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
        
        <!-- Cards de KPIs (Resumo) -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
            <div class="bg-white p-6 rounded-lg shadow-sm">
                <h3 class="text-sm font-medium text-gray-500">Vendas Totais</h3>
                <p id="kpi-total-sales" class="mt-1 text-3xl font-semibold text-gray-900">R$ ...</p>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-sm">
                <h3 class="text-sm font-medium text-gray-500">Pedidos</h3>
                <p id="kpi-total-orders" class="mt-1 text-3xl font-semibold text-gray-900">...</p>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-sm">
                <h3 class="text-sm font-medium text-gray-500">Clientes em Risco</h3>
                <p id="kpi-risky-customers" class="mt-1 text-3xl font-semibold text-red-600">...</p>
            </div>
        </div>

        <!-- Construtor de Análise (A "Pivot Table" da Maria) -->
        <div class="bg-white p-6 rounded-lg shadow-sm mb-6">
            <h2 class="text-lg font-medium text-gray-900 mb-4">Análise Customizada</h2>
            <p class="text-sm text-gray-600 mb-4">Responda suas perguntas. Comece selecionando uma métrica e uma dimensão para explorar.</p>
            
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                <!-- Filtros -->
                <select id="filter-metric" class="rounded-md border-gray-300 shadow-sm">
                    <option value="total_sales">Métrica: Vendas Totais</option>
                    <option value="total_orders">Métrica: Total de Pedidos</option>
                </select>
                
                <select id="filter-dimension" class="rounded-md border-gray-300 shadow-sm">
                    <option value="channel">Dimensão: Canal (iFood, Rappi...)</option>
                    <option value="product_name">Dimensão: Produto</option>
                    <option value="region">Dimensão: Região de Entrega</option>
                    <option value="day_of_week">Dimensão: Dia da Semana</option>
                    <option value="hour_of_day">Dimensão: Hora do Dia</option>
                </select>

                <!-- Filtros adicionais -->
                <select id="filter-channel" class="rounded-md border-gray-300 shadow-sm">
                    <option value="all">Canal: Todos</option>
                    <option value="iFood">iFood</option>
                    <option value="Rappi">Rappi</option>
                    <option value="WhatsApp">WhatsApp</option>
                    <option value="Presencial">Presencial</option>
                </select>
                
                <button id="run-query" class="bg-indigo-600 text-white px-4 py-2 rounded-md shadow-sm hover:bg-indigo-700">
                    Analisar
                </button>
            </div>
        </div>

        <!-- Área de Gráficos -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <!-- Gráfico 1: Análise Customizada -->
            <div class="bg-white p-6 rounded-lg shadow-sm">
                <h3 id="chart1-title" class="text-lg font-medium text-gray-900 mb-4">Sua Análise</h3>
                <canvas id="chart1"></canvas>
            </div>

            <!-- Gráfico 2: Desempenho de Entregas (Pergunta 2) -->
            <div class="bg-white p-6 rounded-lg shadow-sm">
                <h3 class="text-lg font-medium text-gray-900 mb-4">Tempo Médio de Entrega (min) por Região</h3>
                <canvas id="chart2"></canvas>
            </div>
        </div>

    </main>

    <script>
        // --- INÍCIO DO BACKEND/DB SIMULADO ---
        // Nesta seção, simulamos o Banco de Dados, o dbt e o FastAPI.
        // No mundo real, isso rodaria no servidor.

        let RAW_DATA = [];
        let ANALYTICS_DATA = {};
        let CHARTS = {};
        const TODAY = dayjs();

        const MOCK_CONFIG = {
            stores: ["Loja Centro", "Loja Shopping", "Loja Bairro"],
            products: [
                { id: 1, name: "Burger Clássico", price: 25.50 },
                { id: 2, name: "Burger Vegano", price: 28.00 },
                { id: 3, name: "Batata Frita G", price: 15.00 },
                { id: 4, name: "Refrigerante Lata", price: 8.00 },
                { id: 5, name: "Milkshake Ovomaltine", price: 22.00 },
            ],
            channels: ["iFood", "Rappi", "WhatsApp", "Presencial"],
            regions: ["Zona Sul", "Zona Norte", "Centro", "Zona Oeste"],
            customer_ids: Array.from({ length: 500 }, (_, i) => `customer_${i + 1}`),
        };

        // Função para gerar um número aleatório
        function rand(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // Função para gerar um pedido aleatório (Simula o `generate_data.py`)
        function createMockOrder(date) {
            const customer_id = MOCK_CONFIG.customer_ids[rand(0, 499)];
            const channel = MOCK_CONFIG.channels[rand(0, 3)];
            const product = MOCK_CONFIG.products[rand(0, 4)];
            const region = MOCK_CONFIG.regions[rand(0, 3)];
            
            // Simula horários de pico (noite)
            const hour = rand(10, 23);
            const created_at = date.hour(hour).minute(rand(0, 59)).second(rand(0, 59));
            
            const delivery_time_min = (channel === "Presencial") ? null : rand(20, 70);
            
            return {
                order_id: `order_${rand(10000, 99999)}`,
                customer_id: customer_id,
                created_at: created_at.toISOString(),
                channel: channel,
                product_id: product.id,
                product_name: product.name,
                total_sales: product.price,
                region: region,
                delivery_time_min: delivery_time_min,
                day_of_week: created_at.weekday(), // 0 = Domingo, 1 = Segunda... 4 = Quinta
                hour_of_day: hour,
            };
        }

        // 1. SIMULAÇÃO DO BANCO DE DADOS (OLTP)
        // Gera 5.000 vendas (suficiente para o browser) nos últimos 180 dias
        console.log("Simulando banco de dados... Gerando 5.000 vendas...");
        RAW_DATA = Array.from({ length: 5000 }, () => {
            const randomDayAgo = rand(0, 180);
            const date = TODAY.subtract(randomDayAgo, 'day');
            return createMockOrder(date);
        });
        console.log("Banco de dados simulado com", RAW_DATA.length, "registros.");

        
        // 2. SIMULAÇÃO DO ETL (dbt)
        // Processa os dados brutos e cria "Data Marts" pré-agregados
        // Esta é a parte mais importante para a performance.
        
        function runETL(data, daysAgo) {
            console.log(`Rodando ETL (simulação dbt) para ${daysAgo} dias...`);
            
            // Filtra os dados brutos pelo período selecionado
            const startDate = TODAY.subtract(daysAgo, 'day').startOf('day');
            const filteredData = data.filter(d => dayjs(d.created_at).isAfter(startDate));
            console.log(`Dados filtrados: ${filteredData.length} registros.`);

            // --- Mart 1: Perguntas Customizadas (Agregador Genérico) ---
            // Não vamos pré-agregar tudo, mas filtramos o dataset
            const customAnalysisData = filteredData;

            // --- Mart 2: Performance de Entrega (Pergunta 2) ---
            const deliveryByRegion = {};
            filteredData.forEach(d => {
                if (d.delivery_time_min) {
                    if (!deliveryByRegion[d.region]) {
                        deliveryByRegion[d.region] = { total_time: 0, count: 0 };
                    }
                    deliveryByRegion[d.region].total_time += d.delivery_time_min;
                    deliveryByRegion[d.region].count++;
                }
            });
            const mart_delivery_performance = Object.keys(deliveryByRegion).map(region => ({
                region: region,
                avg_delivery_time: (deliveryByRegion[region].total_time / deliveryByRegion[region].count).toFixed(1),
            })).sort((a, b) => b.avg_delivery_time - a.avg_delivery_time);


            // --- Mart 3: Clientes RFM (Pergunta 3) ---
            // Usamos os dados *completos* (não filtrados) para RFM
            const customerData = {};
            data.forEach(d => {
                if (!customerData[d.customer_id]) {
                    customerData[d.customer_id] = { total_orders: 0, last_order_date: null };
                }
                customerData[d.customer_id].total_orders++;
                const orderDate = dayjs(d.created_at);
                if (!customerData[d.customer_id].last_order_date || orderDate.isAfter(customerData[d.customer_id].last_order_date)) {
                    customerData[d.customer_id].last_order_date = orderDate;
                }
            });

            let riskyCustomersCount = 0;
            Object.keys(customerData).forEach(customerId => {
                const customer = customerData[customerId];
                const days_since_last_order = TODAY.diff(customer.last_order_date, 'day');
                
                // "Quais clientes compraram 3+ vezes mas não voltam há 30 dias?"
                if (customer.total_orders >= 3 && days_since_last_order > 30) {
                    riskyCustomersCount++;
                }
            });

            // KPIs
            const kpi_total_sales = filteredData.reduce((sum, d) => sum + d.total_sales, 0);
            const kpi_total_orders = filteredData.length;

            return {
                customAnalysisData,
                mart_delivery_performance,
                kpi_total_sales,
                kpi_total_orders,
                kpi_risky_customers: riskyCustomersCount,
            };
        }


        // 3. SIMULAÇÃO DA API (FastAPI)
        // Funções que o frontend chama para "buscar" os dados.

        // API Endpoint: /api/v1/kpis-and-charts
        function fetchData(daysAgo) {
            ANALYTICS_DATA = runETL(RAW_DATA, daysAgo);
            updateDashboard();
        }

        // API Endpoint: /api/v1/custom-query
        function runCustomQuery() {
            const metric = document.getElementById('filter-metric').value;
            const dimension = document.getElementById('filter-dimension').value;
            const channelFilter = document.getElementById('filter-channel').value;

            console.log(`Rodando query customizada: ${metric} por ${dimension}, filtro: ${channelFilter}`);

            // 1. Aplicar filtros
            let data = ANALYTICS_DATA.customAnalysisData;
            if (channelFilter !== 'all') {
                data = data.filter(d => d.channel === channelFilter);
            }
            
            // 2. Responder à Pergunta 1
            // "Qual produto vende mais na quinta à noite no iFood?"
            // Para testar: Métrica=Vendas, Dimensão=Produto, Canal=iFood
            // E adicionar filtros de dia/hora (aqui simplificado)
            if (channelFilter === 'iFood' && dimension === 'product_name') {
                 // Filtra para "Quinta à noite" (dia 4, hora 19-23)
                 data = data.filter(d => d.day_of_week === 4 && d.hour_of_day >= 19);
                 console.log("Aplicando filtro especial 'Quinta à noite no iFood'");
            }

            // 3. Agregar dados (GROUP BY)
            const aggregation = {};
            data.forEach(d => {
                const dimValue = d[dimension];
                if (!aggregation[dimValue]) {
                    aggregation[dimValue] = { total_sales: 0, total_orders: 0 };
                }
                aggregation[dimValue].total_sales += d.total_sales;
                aggregation[dimValue].total_orders++;
            });

            // 4. Formatar para o gráfico
            const sortedData = Object.keys(aggregation).map(dimValue => ({
                dimension: dimValue,
                metric_value: aggregation[dimValue][metric],
            })).sort((a, b) => b.metric_value - a.metric_value).slice(0, 10); // Top 10

            // Nomes amigáveis para dias da semana
            const dayMap = ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"];
            if (dimension === 'day_of_week') {
                sortedData.forEach(d => d.dimension = dayMap[d.dimension] || "N/A");
            }
            if (dimension === 'hour_of_day') {
                sortedData.forEach(d => d.dimension = `${d.dimension}h`);
            }

            // 5. Renderizar o gráfico
            const chartTitle = `${document.getElementById('filter-metric').options[document.getElementById('filter-metric').selectedIndex].text} por ${document.getElementById('filter-dimension').options[document.getElementById('filter-dimension').selectedIndex].text}`;
            document.getElementById('chart1-title').innerText = chartTitle;
            
            updateChart('chart1', {
                labels: sortedData.map(d => d.dimension),
                datasets: [{
                    label: metric,
                    data: sortedData.map(d => d.metric_value),
                    backgroundColor: 'rgba(79, 70, 229, 0.8)',
                    borderColor: 'rgba(79, 70, 229, 1)',
                    borderWidth: 1
                }]
            });
        }

        // --- FIM DO BACKEND/DB SIMULADO ---


        // --- INÍCIO DO FRONTEND (React Simulado) ---

        function updateChart(chartId, data, type = 'bar') {
            const ctx = document.getElementById(chartId).getContext('2d');
            
            if (CHARTS[chartId]) {
                CHARTS[chartId].destroy(); // Destrói gráfico anterior para evitar bugs
            }
            
            CHARTS[chartId] = new Chart(ctx, {
                type: type,
                data: data,
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });
        }

        function updateDashboard() {
            // 1. Atualizar KPIs
            document.getElementById('kpi-total-sales').innerText = ANALYTICS_DATA.kpi_total_sales.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
            document.getElementById('kpi-total-orders').innerText = ANALYTICS_DATA.kpi_total_orders.toLocaleString('pt-BR');
            document.getElementById('kpi-risky-customers').innerText = ANALYTICS_DATA.kpi_risky_customers.toLocaleString('pt-BR');
            
            // 2. Atualizar Gráfico 2 (Performance de Entrega)
            const deliveryData = ANALYTICS_DATA.mart_delivery_performance;
            updateChart('chart2', {
                labels: deliveryData.map(d => d.region),
                datasets: [{
                    label: 'Tempo Médio (min)',
                    data: deliveryData.map(d => d.avg_delivery_time),
                    backgroundColor: 'rgba(219, 39, 119, 0.8)',
                }]
            });

            // 3. Rodar a query customizada padrão
            runCustomQuery();
        }

        // --- Inicialização ---
        document.addEventListener('DOMContentLoaded', () => {
            // Registra os "event listeners"
            document.getElementById('date-range').addEventListener('change', (e) => {
                fetchData(e.target.value);
            });
            
            document.getElementById('run-query').addEventListener('click', runCustomQuery);

            // Carga Inicial
            fetchData(document.getElementById('date-range').value);
        });

    </script>
</body>
</html>
